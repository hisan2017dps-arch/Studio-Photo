
// Use correct imports as per @google/genai guidelines
import { GoogleGenAI, Type, GenerateContentResponse } from "@google/genai";

export class GeminiService {
  /**
   * Generates a descriptive prompt based on an uploaded image and the specific menu context.
   */
  async generatePromptFromImage(imageBase64: string, menuName: string, lang: string): Promise<string> {
    const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });
    
    // Explicitly structure image part to match SDK Part type
    const imagePart = {
      inlineData: {
        data: imageBase64.split(',')[1],
        mimeType: imageBase64.split(';')[0].split(':')[1]
      }
    };

    const textPart = {
      text: `Analyze this image and create a short but descriptive image generation prompt. 
             Menu Context: "${menuName}".
             Instructions: Write a 1-2 sentence prompt in ${lang === 'id' ? 'Bahasa Indonesia' : 'English'} 
             that describes the style, subject, and lighting for an AI generator.`
    };

    // Use correct single-turn content structure as per guidelines
    const response: GenerateContentResponse = await ai.models.generateContent({
      model: 'gemini-3-flash-preview',
      contents: { parts: [imagePart, textPart] },
    });

    // Use response.text property
    return response.text || "";
  }

  /**
   * Refines an existing prompt text using the reference image and menu context.
   */
  async refinePrompt(currentPrompt: string, imageBase64: string | null | undefined, menuName: string, lang: string): Promise<string> {
    const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });
    
    const parts: any[] = [];
    if (imageBase64) {
      parts.push({
        inlineData: {
          data: imageBase64.split(',')[1],
          mimeType: imageBase64.split(';')[0].split(':')[1]
        }
      });
    }

    parts.push({
      text: `Enhance this prompt to be more professional and artistic: "${currentPrompt}". 
             Context: "${menuName}".
             Return ONLY the enhanced prompt string in ${lang === 'id' ? 'Bahasa Indonesia' : 'English'}.`
    });

    // Use correct content structure
    const response: GenerateContentResponse = await ai.models.generateContent({
      model: 'gemini-3-flash-preview',
      contents: { parts },
    });

    return response.text || currentPrompt;
  }

  /**
   * Generates images. Uses Gemini 2.5 Flash Image
   */
  async generateImage(prompt: string, aspectRatio: string = '1:1'): Promise<string> {
    const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });
    
    // Ensure the aspect ratio string matches the SDK requirements exactly
    // Use correct content structure for single-turn
    const response: GenerateContentResponse = await ai.models.generateContent({
      model: 'gemini-2.5-flash-image',
      contents: { parts: [{ text: prompt }] },
      config: {
        imageConfig: {
          aspectRatio: aspectRatio as any
        }
      }
    });

    // Iterate through parts to find the image part as per guidelines
    const parts = response.candidates?.[0]?.content?.parts || [];
    for (const part of parts) {
      if (part.inlineData) {
        return `data:${part.inlineData.mimeType};base64,${part.inlineData.data}`;
      }
    }
    throw new Error("No image generated by model");
  }

  /**
   * Transforms existing images using Gemini 2.5 Flash Image
   */
  async transformImage(prompt: string, sourceImages: string[], aspectRatio: string = '1:1'): Promise<string> {
    const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });
    const parts: any[] = sourceImages.map(img => ({
      inlineData: {
        data: img.split(',')[1],
        mimeType: img.split(';')[0].split(':')[1]
      }
    }));

    parts.push({ text: prompt });

    // Use correct content structure
    const response: GenerateContentResponse = await ai.models.generateContent({
      model: 'gemini-2.5-flash-image',
      contents: { parts },
      config: {
        imageConfig: {
          aspectRatio: aspectRatio as any
        }
      }
    });

    // Iterate through parts to find the image part
    for (const part of response.candidates?.[0]?.content?.parts || []) {
      if (part.inlineData) {
        return `data:${part.inlineData.mimeType};base64,${part.inlineData.data}`;
      }
    }
    throw new Error("Transformation failed to return an image");
  }

  /**
   * Intelligent chat using multimodal gemini-3-pro-preview
   */
  async chat(history: any[]) {
    const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });
    const response: GenerateContentResponse = await ai.models.generateContent({
      model: 'gemini-3-pro-preview',
      contents: history,
      config: { thinkingConfig: { thinkingBudget: 0 } }
    });

    const parts = response.candidates?.[0]?.content?.parts || [];
    return parts.map(p => {
      // Use proper property checks for response parts
      if (p.text) return { type: 'text', text: p.text };
      if (p.inlineData) return { type: 'image', url: `data:${p.inlineData.mimeType};base64,${p.inlineData.data}` };
      return null;
    }).filter(Boolean);
  }

  /**
   * Structured data extraction
   */
  async extractRecipe(text: string) {
    const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });
    const response: GenerateContentResponse = await ai.models.generateContent({
      model: 'gemini-3-flash-preview',
      contents: { parts: [{ text: `Extract recipe details from this text: ${text}` }] },
      config: {
        responseMimeType: 'application/json',
        responseSchema: {
          type: Type.OBJECT,
          properties: {
            recipe_name: { type: Type.STRING },
            prep_time_minutes: { type: Type.INTEGER },
            ingredients: {
              type: Type.ARRAY,
              items: {
                type: Type.OBJECT,
                properties: {
                  name: { type: Type.STRING },
                  quantity: { type: Type.STRING }
                }
              }
            },
            instructions: { type: Type.ARRAY, items: { type: Type.STRING } }
          },
          required: ["recipe_name", "prep_time_minutes", "ingredients", "instructions"]
        }
      }
    });
    // Use response.text property and handle undefined
    return JSON.parse(response.text || '{}');
  }

  /**
   * Google Search Grounding with Visualization
   */
  async getLiveVisuals(prompt: string) {
    const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });
    
    const searchRes: GenerateContentResponse = await ai.models.generateContent({
      model: 'gemini-3-flash-preview',
      contents: { parts: [{ text: `Search Google for current info about: "${prompt}". Summarize and then write an image prompt starting with 'IMAGE_PROMPT: '.` }] },
      config: { tools: [{ googleSearch: {} }] }
    });

    const text = searchRes.text || "";
    const splitIndex = text.indexOf("IMAGE_PROMPT:");
    const summary = splitIndex > -1 ? text.substring(0, splitIndex).trim() : text;
    const imgPrompt = splitIndex > -1 ? text.substring(splitIndex + 13).trim() : prompt;

    const imgUrl = await this.generateImage(imgPrompt, '16:9');

    return {
      summary,
      imageUrl: imgUrl,
      groundingMetadata: searchRes.candidates?.[0]?.groundingMetadata
    };
  }
}

export const gemini = new GeminiService();
